<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2048 Neon Edition</title>
  <style>
    :root{
      --bg1:#0f1020; --bg2:#161a30; --board:#1f244a; --cell:#151935; --text:#eaf0ff;
      --accent:#7aa2ff; --accent2:#70ffd9; --danger:#ff4d6d; --gold:#ffd166;
      --gap:12px; --tile:92px; --radius:18px; --shadow:0 10px 24px rgba(0,0,0,.45);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; display:flex; align-items:center; justify-content:center; flex-direction:column;
      background: radial-gradient(1200px 600px at 20% 10%, #1a1f3d 0%, transparent 60%),
                  radial-gradient(1000px 800px at 80% 90%, #132a4a 0%, transparent 70%),
                  linear-gradient(135deg, var(--bg1), var(--bg2));
      color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial;
      overflow:hidden;
    }
    .wrap{width:min(500px, 90vw);}
    header{display:flex; justify-content:space-between; align-items:center; margin-bottom:16px}
    h1{margin:0; font-size:clamp(24px,4vw,32px); letter-spacing:.5px}
    .scores{display:flex; gap:10px}
    .badge{background:#0b0f26aa; padding:10px 14px; border-radius:12px; box-shadow:var(--shadow); backdrop-filter: blur(6px);
      border:1px solid #ffffff10; min-width:90px; text-align:center}
    .badge .label{font-size:12px; opacity:.75}
    .badge .value{font-size:20px; font-weight:800}

    .controls{display:flex; gap:10px; margin-bottom:12px}
    button{
      appearance:none; border:none; cursor:pointer; padding:10px 14px; border-radius:12px; font-weight:700; color:var(--text);
      background: linear-gradient(135deg, #2b3b8e, #3b68ff 60%, #34d3a7);
      box-shadow: 0 6px 16px rgba(53,119,255,.35), inset 0 1px 0 rgba(255,255,255,.15);
      transition: transform .08s ease, filter .2s ease, box-shadow .2s ease; outline:none;
    }
    button:hover{transform:translateY(-1px)}
    button:active{transform:translateY(1px)}
    .ghost{background:#0b0f26aa}
    .danger{background:linear-gradient(135deg, #ff4d6d, #ff8fab)}

    .board{
      position:relative; width: calc(var(--tile)*4 + var(--gap)*5); height: calc(var(--tile)*4 + var(--gap)*5);
      background: linear-gradient(180deg, #1b2044, #161a39); border-radius: 24px; padding: var(--gap);
      box-shadow: 0 20px 60px rgba(0,0,0,.6), inset 0 0 0 1px rgba(255,255,255,.05);
      overflow:hidden;
    }
    .grid{display:grid; grid-template-columns: repeat(4, var(--tile)); grid-template-rows: repeat(4, var(--tile)); gap:var(--gap);}
    .cell{background: #0e1230; border-radius: var(--radius); box-shadow: inset 0 0 0 1px rgba(255,255,255,.05);}

    /* Tiles */
    .tile{position:absolute; width:var(--tile); height:var(--tile); border-radius: var(--radius);
      display:flex; align-items:center; justify-content:center; font-weight:900; font-size:28px; color:#eaf0ff;
      transform: translate3d(0,0,0); will-change: transform; filter: drop-shadow(0 8px 18px rgba(0,0,0,.45));
      transition: transform .12s ease-in, scale .1s ease-in; user-select:none;
    }
    .tile.appear{animation: pop .14s ease-out}
    .tile.merge{animation: pulse .16s ease-out}
    @keyframes pop{from{transform:scale(.6)} to{transform:scale(1)}}
    @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.12)}100%{transform:scale(1)}}

    /* Neon backgrounds per value */
    .v2{background: radial-gradient(120px 80px at 30% 30%, #3344aa 0%, #222a66 60%); box-shadow: 0 0 22px #3453ff55}
    .v4{background: radial-gradient(120px 80px at 30% 30%, #2a7ab3 0%, #1a3b66 60%); box-shadow: 0 0 22px #2ad2ff55}
    .v8{background: radial-gradient(120px 80px at 30% 30%, #2a9d8f 0%, #1a5a54 60%); box-shadow: 0 0 28px #2affcf55}
    .v16{background: radial-gradient(120px 80px at 30% 30%, #7bd87b 0%, #2a7b2a 60%); box-shadow: 0 0 28px #7bff7b55}
    .v32{background: radial-gradient(120px 80px at 30% 30%, #ffd166 0%, #8a5e1a 60%); box-shadow: 0 0 34px #ffd16666}
    .v64{background: radial-gradient(120px 80px at 30% 30%, #ff9f1c 0%, #8a3e00 60%); box-shadow: 0 0 36px #ffb85e77}
    .v128{background: radial-gradient(120px 80px at 30% 30%, #ff4d6d 0%, #7a1a2a 60%); box-shadow: 0 0 40px #ff4d6d88; color:#fff}
    .v256{background: radial-gradient(120px 80px at 30% 30%, #d66bff 0%, #5b1a7a 60%); box-shadow: 0 0 44px #d66bff88}
    .v512{background: radial-gradient(120px 80px at 30% 30%, #7aa2ff 0%, #1a2a7a 60%); box-shadow: 0 0 48px #7aa2ffaa}
    .v1024{background: radial-gradient(120px 80px at 30% 30%, #70ffd9 0%, #0d4a4a 60%); box-shadow: 0 0 52px #70ffd9aa; font-size:24px}
    .v2048{background: radial-gradient(140px 90px at 30% 30%, #ffe45e 0%, #7a5a00 60%); box-shadow: 0 0 60px #ffe45eaa; color:#101010; font-size:24px}

    .status{position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:linear-gradient(#0a0e25cc,#0a0e25cc); border-radius:24px}
    .status.show{display:flex}
    .status .panel{background:#0b0f26aa; border:1px solid #ffffff14; padding:24px; border-radius:16px; text-align:center; backdrop-filter: blur(8px)}
    .panel h2{margin:0 0 6px 0}

    /* Helper text */
    .hint{opacity:.7; font-size:12px; text-align:center; margin-top:10px}

    /* Mobile sizing */
    @media (max-width:420px){
      :root{--tile:70px; --gap:10px}
      .tile{font-size:22px}
      .v1024,.v2048{font-size:20px}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>2048 <span style="opacity:.6">Neon Edition</span></h1>
      <div class="scores">
        <div class="badge"><div class="label">分數</div><div id="score" class="value">0</div></div>
        <div class="badge"><div class="label">最佳</div><div id="best" class="value">0</div></div>
      </div>
    </header>

    <div class="controls">
      <button id="new">新遊戲</button>
      <button id="undo" class="ghost">復原一步 ⤺</button>
      <button id="ai" class="ghost">自動移動 ▶︎</button>
      <button id="clear" class="danger">清除紀錄</button>
    </div>

    <div class="board" id="board">
      <div class="grid" aria-hidden="true"></div>
      <!-- static cells -->
      <script>
        // render static cells
        document.currentScript.previousElementSibling.innerHTML = Array.from({length:16}).map(_=>'<div class="cell"></div>').join('')
      </script>
      <div class="status" id="status">
        <div class="panel">
          <h2 id="status-title">遊戲結束</h2>
          <div id="status-desc">再挑戰一次吧！</div>
          <div style="height:12px"></div>
          <button id="again">再玩一次</button>
        </div>
      </div>
    </div>

    <div class="hint">鍵盤方向鍵 / WASD / 觸控滑動可操作。合併 2048 有華麗特效 ✨</div>
  </div>

  <script>
  // --- Utility ---
  const $ = s => document.querySelector(s);
  const boardEl = $('#board');
  const scoreEl = $('#score');
  const bestEl = $('#best');
  const statusEl = $('#status');
  const statusTitle = $('#status-title');
  const statusDesc = $('#status-desc');
  const LS_KEY = 'neon2048';

  const rnd = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const posToXY = (p)=>({x:p%4, y:Math.floor(p/4)});
  const xyToPos = (x,y)=> y*4+x;
  const tilePosPx = (x,y)=>`translate(${(x)*(getTile()+getGap())+getGap()}px, ${(y)*(getTile()+getGap())+getGap()}px)`;
  const getGap = ()=> parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'));
  const getTile = ()=> parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile'));

  function save(state){
    const best = Math.max(load().best||0, state.best||0, state.score||0);
    localStorage.setItem(LS_KEY, JSON.stringify({...state, best}));
  }
  function load(){
    try{ return JSON.parse(localStorage.getItem(LS_KEY)||'{}'); }catch(e){ return {}; }
  }

  // --- Game State ---
  class Game{
    constructor(){
      this.tiles=[]; // {id, x,y, value}
      this.idSeq=1;
      this.score=0; this.best=load().best||0;
      this.history=[]; // undo stack
      this.animLock=false;
      this.auto=null; // auto-move interval
      this.spawn(2); this.spawn();
      this.render(true);
    }
    clone(){
      return { tiles: this.tiles.map(t=>({...t})), score:this.score };
    }
    restore(s){ this.tiles = s.tiles.map(t=>({...t})); this.score=s.score; this.render(true); }

    emptyPositions(){
      const filled = new Set(this.tiles.map(t=>xyToPos(t.x,t.y)));
      const arr=[]; for(let p=0;p<16;p++){ if(!filled.has(p)) arr.push(p); }
      return arr;
    }
    tileAt(x,y){ return this.tiles.find(t=>t.x===x && t.y===y); }

    spawn(n=1){
      for(let i=0;i<n;i++){
        const empties = this.emptyPositions(); if(empties.length===0) return;
        const pos = empties[rnd(0, empties.length-1)]; const {x,y}=posToXY(pos);
        const value = Math.random()<0.9?2:4;
        this.tiles.push({id:this.idSeq++, x,y,value, new:true});
      }
      this.saveBest();
    }
    saveBest(){ this.best = Math.max(this.best, this.score); save({score:this.score, best:this.best}); bestEl.textContent=this.best; }

    move(dir){
      if(this.animLock) return;
      // dir: 0=left,1=up,2=right,3=down
      const dirVec = [ {x:-1,y:0},{x:0,y:-1},{x:1,y:0},{x:0,y:1} ][dir];
      const order = (a,b)=> dir===0? a.x-b.x : dir===1? a.y-b.y : dir===2? b.x-a.x : b.y-a.y;

      const before = JSON.stringify(this.tiles.map(t=>({x:t.x,y:t.y,value:t.value})).sort((a,b)=>a.y-b.y||a.x-b.x));
      const snapshot = this.clone();

      // clear flags
      this.tiles.forEach(t=>{delete t.new; delete t.merged;});

      let moved=false;
      // For each line
      const lines = dir%2===0 ? 4 : 4; // always 4 lines
      for(let i=0;i<4;i++){
        const lineTiles = this.tiles.filter(t=> dir%2===0 ? t.y===i : t.x===i).sort(order);
        let targetIndex = 0;
        let lastValue = null; let lastTile = null;
        for(const tile of lineTiles){
          // compute target x,y
          let tx = tile.x, ty=tile.y;
          const getIndex = ()=> dir%2===0 ? tx : ty;
          const setIndex = v=> dir%2===0 ? (tx=v) : (ty=v);

          // next open slot
          setIndex(targetIndex);
          if(lastValue===tile.value){ // merge
            setIndex(targetIndex-1);
            const mergeInto = lastTile; // merge
            // move to mergeInto position
            if(tile.x!==mergeInto.x || tile.y!==mergeInto.y) moved=true;
            tile.x=mergeInto.x; tile.y=mergeInto.y; tile.remove=true; // mark to remove after animation
            mergeInto.value*=2; mergeInto.merged=true; lastValue=null; lastTile=null;
            this.score += mergeInto.value;
            this.spark(mergeInto);
          }else{
            if((dir===0 && tx!==targetIndex) || (dir===2 && tx!==3-(3-targetIndex)) || (dir===1 && ty!==targetIndex) || (dir===3 && ty!==3-(3-targetIndex))){ moved=true; }
            lastValue = tile.value; lastTile = tile; setIndex(targetIndex); targetIndex++;
          }
          tile.x=tx; tile.y=ty;
        }
      }

      const after = JSON.stringify(this.tiles.map(t=>({x:t.x,y:t.y,value:t.value})).sort((a,b)=>a.y-b.y||a.x-b.x));
      if(before!==after){
        this.history.push(snapshot);
        this.render();
        this.animLock=true;
        setTimeout(()=>{
          this.tiles = this.tiles.filter(t=>!t.remove);
          if(this.emptyPositions().length>0) this.spawn();
          this.render(true);
          this.animLock=false;
          this.checkEnd();
        }, 130);
      }
    }

    movesAvailable(){
      if(this.emptyPositions().length>0) return true;
      // check merges
      for(const t of this.tiles){
        const n = [[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dx,dy] of n){
          const nx=t.x+dx, ny=t.y+dy; if(nx<0||nx>3||ny<0||ny>3) continue;
          const u=this.tileAt(nx,ny); if(u && u.value===t.value) return true;
        }
      }
      return false;
    }

    checkEnd(){
      this.saveBest(); scoreEl.textContent=this.score;
      if(!this.movesAvailable()){
        statusTitle.textContent='遊戲結束';
        statusDesc.textContent=`最終分數 ${this.score} 分`;
        statusEl.classList.add('show');
        this.shake();
      }
      if(this.tiles.some(t=>t.value>=2048)){
        statusTitle.textContent='恭喜達成 2048!';
        statusDesc.textContent='繼續挑戰更高分吧！';
        statusEl.classList.add('show');
        this.confetti();
      }
    }

    undo(){
      if(this.history.length===0) return;
      const s = this.history.pop(); this.restore(s); this.saveBest(); scoreEl.textContent=this.score;
    }

    render(skipAnim=false){
      // remove missing DOM
      const exists = new Set(this.tiles.map(t=>t.id));
      [...boardEl.querySelectorAll('.tile')].forEach(el=>{ if(!exists.has(+el.dataset.id)) el.remove(); });

      // update/create
      for(const t of this.tiles){
        let el = boardEl.querySelector(`.tile[data-id="${t.id}"]`);
        if(!el){
          el = document.createElement('div'); el.className='tile'; el.dataset.id=t.id; el.textContent = t.value; el.classList.add('v'+t.value);
          boardEl.appendChild(el); if(t.new) el.classList.add('appear');
        }
        el.textContent = t.value; [...el.classList].forEach(c=>/^v\d+$/i.test(c)&&el.classList.remove(c)); el.classList.add('v'+t.value);
        el.style.transform = tilePosPx(t.x,t.y);
        if(t.merged){ el.classList.add('merge'); setTimeout(()=>el.classList.remove('merge'), 180); }
        if(skipAnim){ el.style.transition='none'; requestAnimationFrame(()=>{el.style.transition='transform .12s ease-in'}); }
      }
      scoreEl.textContent=this.score; bestEl.textContent=this.best;
    }

    reset(){
      this.tiles=[]; this.idSeq=1; this.score=0; this.history=[]; this.animLock=false; statusEl.classList.remove('show');
      this.spawn(2); this.render(true); save({score:0, best:this.best});
    }

    spark(tile){
      // particle burst on merge
      const count = Math.min(24, 8 + Math.log2(tile.value)*4);
      const origin = this.tileCenter(tile);
      for(let i=0;i<count;i++){
        const p = document.createElement('div');
        p.style.position='absolute'; p.style.left=origin.x+'px'; p.style.top=origin.y+'px';
        p.style.width=p.style.height=(6+Math.random()*6)+'px'; p.style.borderRadius='50%';
        p.style.background = `hsl(${Math.random()*360},100%,65%)`;
        p.style.boxShadow='0 0 12px rgba(255,255,255,.5)'; p.style.pointerEvents='none';
        boardEl.appendChild(p);
        const ang=Math.random()*Math.PI*2, dist=40+Math.random()*80, dx=Math.cos(ang)*dist, dy=Math.sin(ang)*dist;
        p.animate([{transform:'translate(0,0)', opacity:1},{transform:`translate(${dx}px,${dy}px)`, opacity:0}], {duration:420, easing:'ease-out'});
        setTimeout(()=>p.remove(), 450);
      }
    }
    tileCenter(tile){
      const gap=getGap(), size=getTile();
      const x=gap + tile.x*(gap+size)+ size/2; const y=gap + tile.y*(gap+size)+ size/2; return {x,y};
    }

    shake(){ boardEl.animate([{transform:'translateX(0)'},{transform:'translateX(-6px)'},{transform:'translateX(6px)'},{transform:'translateX(0)'}], {duration:250}); }

    confetti(){
      for(let i=0;i<120;i++){
        const s = document.createElement('div'); s.style.position='absolute'; s.style.left=rnd(0,boardEl.clientWidth)+'px'; s.style.top='-10px'; s.style.width=s.style.height=(4+rnd(0,4))+'px';
        s.style.background=`hsl(${rnd(0,360)},100%,60%)`; s.style.opacity='.9'; s.style.filter='drop-shadow(0 0 6px rgba(255,255,255,.6))'; s.style.transform='translateY(0)';
        boardEl.appendChild(s);
        s.animate([{transform:'translateY(0)'},{transform:`translateY(${boardEl.clientHeight+30}px)`}], {duration:600+rnd(0,600), easing:'cubic-bezier(.2,.55,.35,1)'});
        setTimeout(()=>s.remove(), 1500);
      }
    }

    // super tiny heuristic auto-move (for fun)
    autoMove(){
      const dirs=[0,1,2,3];
      const test=(dir)=>{const g=new GameGhost(this); g.move(dir); return g.changed? g.score + g.empty()*2 : -1;};
      const bestDir = dirs.map(d=>[d,test(d)]).sort((a,b)=>b[1]-a[1])[0][0];
      this.move(bestDir);
    }
  }

  // A lightweight simulator for heuristic evaluation
  class GameGhost{
    constructor(game){ this.tiles=game.tiles.map(t=>({...t})); this.score=game.score; this.changed=false; }
    empty(){
      const filled = new Set(this.tiles.map(t=>xyToPos(t.x,t.y))); return 16 - filled.size;
    }
    move(dir){
      const order = (a,b)=> dir===0? a.x-b.x : dir===1? a.y-b.y : dir===2? b.x-a.x : b.y-a.y;
      this.tiles.forEach(t=>{delete t.m;});
      const snapshot = JSON.stringify(this.tiles.map(t=>({x:t.x,y:t.y,value:t.value})).sort((a,b)=>a.y-b.y||a.x-b.x));
      for(let i=0;i<4;i++){
        const line = this.tiles.filter(t=> dir%2===0? t.y===i : t.x===i).sort(order);
        let target=0, last=null, lastVal=null;
        for(const tile of line){
          let tx=tile.x, ty=tile.y; const setIndex=v=> dir%2===0? (tx=v):(ty=v);
          setIndex(target);
          if(lastVal===tile.value){ setIndex(target-1); const mergeInto=last; tile.x=mergeInto.x; tile.y=mergeInto.y; mergeInto.value*=2; tile.remove=true; last=null; lastVal=null; this.score+=mergeInto.value; }
          else { last=tile; lastVal=tile.value; setIndex(target); target++; }
          tile.x=tx; tile.y=ty;
        }
      }
      this.tiles = this.tiles.filter(t=>!t.remove);
      const after = JSON.stringify(this.tiles.map(t=>({x:t.x,y:t.y,value:t.value})).sort((a,b)=>a.y-b.y||a.x-b.x));
      this.changed = beforeAfterChanged(snapshot, after);
    }
  }
  function beforeAfterChanged(a,b){ return a!==b; }

  // --- Init ---
  const game = new Game();
  bestEl.textContent = game.best;

  // Controls
  $('#new').onclick = ()=> game.reset();
  $('#again').onclick = ()=> { statusEl.classList.remove('show'); game.reset(); };
  $('#undo').onclick = ()=> game.undo();
  $('#clear').onclick = ()=> { localStorage.removeItem(LS_KEY); bestEl.textContent='0'; };
  let autoTimer=null; $('#ai').onclick = ()=>{
    if(autoTimer){ clearInterval(autoTimer); autoTimer=null; $('#ai').textContent='自動移動 ▶︎'; return; }
    $('#ai').textContent='停止自動 ⏸'; autoTimer=setInterval(()=> game.autoMove(), 120);
  };

  // Keyboard
  window.addEventListener('keydown', (e)=>{
    const k=e.key.toLowerCase();
    if(['arrowleft','a'].includes(k)) game.move(0);
    else if(['arrowup','w'].includes(k)) game.move(1);
    else if(['arrowright','d'].includes(k)) game.move(2);
    else if(['arrowdown','s'].includes(k)) game.move(3);
  });

  // Touch swipe
  let startX=0, startY=0, startT=0;
  boardEl.addEventListener('touchstart', (e)=>{ const t=e.touches[0]; startX=t.clientX; startY=t.clientY; startT=Date.now(); }, {passive:true});
  boardEl.addEventListener('touchend', (e)=>{
    const t=e.changedTouches[0]; const dx=t.clientX-startX, dy=t.clientY-startY; const dt=Date.now()-startT;
    const absX=Math.abs(dx), absY=Math.abs(dy); if(Math.max(absX,absY) < 24) return;
    if(absX>absY) game.move(dx<0?0:2); else game.move(dy<0?1:3);
  }, {passive:true});

  // Resize fix: reposition tiles on viewport change
  const ro = new ResizeObserver(()=> game.render(true)); ro.observe(boardEl);

  </script>
</body>
</html>
